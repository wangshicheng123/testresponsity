// 将一个string变为对象
// eval("("+str+")");

// 必须是json字符串
// json.parse(str)

/* 
message----->  {
                    res.writeHead(200,{"Content-type": "text/html"});
                    res.end();
                }
Application--http(message)


表示层---->xpp(http(message))

会话层----->ssl(xpp(http(message)))----rpc(远端进程控制)

传输层---->tcp(....)---建立高速公路
tcp----传输控制协议
udp----用户数据协议
1： 寻址------把一个东西从a到b，必须知道地址（一栋楼）---根据IP<--->DNS
    端口号----所以要加上门牌号
2：分段与重组----货物的大小---决定了传输的次数{get--一次性4096, post---以+=的方式开辟buffer缓冲区}
分段：根据包头和包体进行分段{ps: 成功率， pe: 误码率}  
3：差错与控制----
4：复用与分解----
5：tcp--流量控制
6：tcp--拥塞控制


tcp与udp的区别：
TCP面向连接（因此需要流量控制和拥塞控制）， udp无连接；
TCP的首部是20字节， UDP是8个字节

早期的的http传输的时候每次都重新建立一个tcp通道----现在的是如果是一个通道，每次http传输的时候可以共用一个tcp通道
早期的http协议是无状态的



解析如下：
分段重组：
（1）：停等协议----速度慢---数据不会乱序
    一段：     a-- arq-->b
             a<-- ack(0|1) --b    ===resu1  
    二段       a-- arq -->b
              a<-- ack(0|1) --b  ====resu2

    重组：res= resu1+resu2;

使用_/h/pe  公式的分段的时候：
如果对于每段数据都同时发送，数据的收到之后可能是乱序的：

滑动窗口协议（gba协议,sr协议）：
（2）：解决乱序的问题
    序号，确认序号

复用与分解：
单路复用，多路复用



一： UDP解析:
    源端口(16)   目的端口 (16)
    数据包长度(16)   校验值(16)
    应用数据data

    数据包长度 ---指示了在UDP报文段中的字节数（首部加数据）
    检验和-----接受方使用检验和来检查在该报文段中是否出错（对恢复差错无能力）
    
    UDP套接字： 由一个二元组来全面标识的
    该二元组包含一个目的IP地址和一个目的端口号

    例如：若两个UDP报文段有不同的源IP地址或者和源端口号，但是
    具有相同的目的IP地址和目的端口号，那么这两个报文段将
    通过相同的套接字被定向到相同的进程；

    注意： （无连接的多路复用和多路分解）因此UDP可以是一对一，一对多，多对一，多对多的；


由于其的无连接的特性，因此没有握手的过程，
乱序到达的（没有流量控制，没有拥塞控制），可以以任何速率进行传输；
无状态---发出去就不管了，没有是否发送成的状态（连接状态，接收和发送缓存（UDP半全工），拥塞控制，序号和确认序号）

存在复用与分解，校验控制

DNS（是将域名转换为IP地址，或将IP地址转换为域名）使用UDP传输---要速度快，只传输包头

二： TCP解析(面向连接的多路复用和多路分解)
特点： 面向连接， 全双工， 有状态
    两部分： 源端口， 目的端口  ---寻址与端口
    序号 ---
    确认序号 --- 乱序的解决部分
    首部（4）  保留（6） URG ACK PSH RST SYN FIN   接受窗口（与缓存接受有关）（16）
    URG---(urg=1表示的是紧急指针有效（），数据在缓存中的优先级最高 )
    ack=1有效确认序号有效，ack=0 
    psh=1  数据不进行缓存，直接给进程
    rsi=1   毁灭进程，一直没有响应
    ftn=1   数据传输成功，关闭进程

    syn--- 创建连接
    ack--- 返回结果
    fzn---关闭连接


    三次握手：(正在铺路，建立通道) 
    a--- syn=1, seq=x(随机数) -->b
    a<--- syn=1, ack=1(是否有效)， ack.seq=x+1(确认信号), seq=y(本次的随机数)  -----b
    a--   ack=1(a向b确认状态),syn=0, seq=x+1, ack.seq=y+1 ---->

    防止断连和半连接（第三次连接是让双方清楚彼此的状态）
    窗口大小---> 流量控制
    缓存-------> 拥塞控制


    四次挥手：
    socket: 在传输层和话层之间创建，（用于常连接）
    a--- fin=1（关闭通道）, seq=u--->
    a<--  ack=1, ack.seq=u+1, seq=v-----b
    a<----fin=1,seq=w,ack.seq=u+1, ----b
    a---  ack=1, seq=w+1, ack.seq=w+1 --------->b

    DNS:(域名解析，把域名转化为IP地址)
    根域名server
    顶级域名server: dms.com, 163.com
    权威域名server: mail.163.com
    本地域名
    hosts

    域名解析的查询方式：
    递归查询：
    A（hosts）<===>B (本地域名) <===>C（权威域名域名）<===> D(顶级域名) <===> E(根域名)
    增加DNS的查询速度---在本地建立一个域名缓存服务器，
    存在代理域名查询
    迭代查询：

    A(hosts)===>{B(本地域名)====>C(顶级域名)
          =====>D(权威域名)
          =====>E(根域名)


    
    校验和（16）    紧急指针（数据来之后先给缓存，之后再给进程）--无需缓存直接给进程（16）
    选项长度（缓存数据长度）--{mss（缓存最大）， 时间戳， 重发}（长度可变，最大不超过32）    填充








全双工： 既听又说---使用缓存实现---tcp
半双工：听不说，说不听----udp








网络层----->IP(.....)----根据IP找具体的方向

数据链路层------>arp/rarp----用于控制传输的方向

物理层---->数据传输
*/


// 会话层--- 从A第到B地（就是一个通道）
// rpc---远端进程控制,  lpc----本地进程控制
